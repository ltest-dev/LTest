(**************************************************************************)
(*                                                                        *)
(*  This file is part of Frama-C.                                         *)
(*                                                                        *)
(*  Copyright (C) 2013-2018                                               *)
(*    CEA (Commissariat à l'énergie atomique et aux énergies              *)
(*         alternatives)                                                  *)
(*                                                                        *)
(*  You may redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 3.                                                *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful, but WITHOUT     *)
(*  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY    *)
(*  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General      *)
(*  Public License for more details.                                      *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version 3 for more          *)
(*  details (enclosed in the file LICENSE).                               *)
(*                                                                        *)
(**************************************************************************)

open Lexing
open Cil_types

let print_std_includes fmt globs =
  if not (Kernel.PrintLibc.get ()) then begin
    let extract_file acc = function
      | AStr s -> Datatype.String.Set.add s acc
      | _ -> Kernel.warning "Unexpected attribute parameter for fc_stdlib"; acc
    in
    let add_file acc g =
      let attrs = Cil_datatype.Global.attr g in
      match Cil.findAttribute "fc_stdlib" attrs with
      | [ arg ] -> extract_file acc arg
      | _ -> acc
    in
    let includes = List.fold_left add_file Datatype.String.Set.empty globs in
    let print_one_include s = Format.fprintf fmt "#include \"%s\"@." s in
    Datatype.String.Set.iter print_one_include includes
  end

module Printer = Printer_builder.Make (struct
    class printer () = object (self)
      inherit Printer.extensible_printer ()
      method! file fmt file =
        Format.fprintf fmt "@[/* Generated by Frama-C LTest */\n\n";
        print_std_includes fmt file.globals;
        Format.fprintf fmt "\n#ifndef pc_label\n#define pc_label(...) do{}while(0)\n\
                            #endif@\n\
                            #ifndef pc_label_bindings\n#define pc_label_bindings(...) do{}while(0)\n\
                            #endif@\n\
                            #ifndef pc_label_sequence\n#define pc_label_sequence(...) do{}while(0)\n\
                            #endif@\n\
                            #ifndef pc_label_sequence_condition\n#define pc_label_sequence_condition(...) do{}while(0)\n\
                            #endif@\n\n";
        Cil.iterGlobals file (fun g -> self#global fmt g);
        Format.fprintf fmt "@]@."
    end
  end)

(** Extracts global variables from an AST *)
let extract_global_vars file =
  let module S = Cil_datatype.Varinfo.Set in
  let f acc global =
    match global with
    | GVar (vi,_,_) -> if Cil.isFunctionType vi.vtype then acc else S.add vi acc
    | GVarDecl (vi,_) -> if Cil.isFunctionType vi.vtype then acc else S.add vi acc
    | _ -> acc
  in
  let globals = Cil.foldGlobals file f S.empty in
  S.elements globals

(* for option slicing = NONE *)
let all_stmts = ref ([]:stmt list)

(* val get_stmt_loc: stmt -> loc *)
let get_stmt_loc = Cil_datatype.Stmt.loc

(* val get_stmt_loc_int: stmt -> int *)
let get_stmt_loc_int s = (fst (get_stmt_loc s)).pos_lnum

(* val same_line: stmt -> stmt -> bool *)
let same_line s1 s2 = (get_stmt_loc_int s1) = (get_stmt_loc_int s2)

(* val mk_call: ?loc:location -> ?result:lval -> string -> exp list -> stmt *)
let mk_call ?(loc=Cil_datatype.Location.unknown) ?result fname args =
  let new_lval loc v = Cil.new_exp loc (Lval (Cil.var v)) in
  let t = match result with
    | Some (Var v, _) -> v.vtype
    | _ -> Cil.voidType in
  let ty = TFun(t, None, false, []) in
  let f = new_lval loc (Cil.makeGlobalVar fname ty) in
  Cil.mkStmt ~valid_sid:true (Instr (Call (result, f, args, loc)))

(* val mkdir: string -> unit *)
let mkdir x =
  if not (Sys.file_exists x) then
    Unix.mkdir x 0o744


(** Indicates whether an instruction is a label. *)
let is_label instr =
  match instr with
  | Call (_, {enode=Lval (Var {vname=name}, NoOffset)}, _, _) ->
    let regexp = Str.regexp_string "pc_label" in
    Str.string_match regexp name 0
  | _ -> false


(**
   Indicates whether an expression is boolean in itself.
   Used to detect boolean expression outside conditional statement
*)
let is_boolean e =
  Options.debug ~level:3 "is boolean? @[%a@]@." Cil_printer.pp_exp e;
  match e.enode with
  (* C99 _Bool type *)
  | BinOp (_, _, _, TInt (IBool, _))
  | UnOp (_, _, TInt (IBool, _))

  (* Use of logical operators or relational operators *)
  | BinOp ((LAnd|LOr|Lt|Gt|Le|Ge|Eq|Ne), _, _, _)
  | UnOp (LNot, _, _) -> true
  | _ -> false

(**
   Get atomic conditions from a boolean expression.
*)
let atomic_conditions =
  let rec aux acc exp =
    match exp.enode with
    | BinOp ((Ne|Eq), a, b, _) ->
      (* Cil adds !=0 when && or || are present in normal expression (don't do that for !)*)
      if Cil.isZero b && is_boolean a then
        aux acc a
      else if Cil.isZero a && is_boolean b then
        aux acc b
      else
        exp :: acc
    | BinOp ((LAnd | LOr), e1, e2, _) ->
      aux (aux acc e1) e2
    | UnOp (LNot, e, _) ->
      aux acc e
    | _ ->
      exp :: acc
  in
  fun exp -> List.rev (aux [] exp)

let rev_combine : int -> 'a list -> 'a list list =
  let rec comb_aux rev_startswith acc n l =
    match n, l with
    | 0, _ -> (List.rev rev_startswith) :: acc
    | _, [] -> acc
    | _, head :: tail ->
      let acc = comb_aux (head :: rev_startswith) acc (n-1) tail in
      comb_aux rev_startswith acc n tail
  in
  fun n l -> comb_aux [] [] n l (*Needed to keep polymorphism, wtf!?*)

(** [combine n l] computes the combinations of [n] elements from the list [l].

    Returns the combination in the order of the list [l].
    For instance, [combine 2 [1;2;3]] returns [[1;2];[1;3];[2;3]].
*)
let combine n (l : 'a list) : 'a list list =
  List.rev (rev_combine n l)

(**
   [sign_combine pos neg l] computes all sign combinations of a list of elements [l], given two sign functions [pos] and [neg].

   Preserves the original order of the list, i.e. each sublist is in the same order.

   For instance, [sign_combine (fun x ->"+"^x) (fun x -> "-"^x) ["1";"2"]] returns [["+1";"+2"];["+1";"-2"];["-1";"+2"];["-1";"-2"]].
*)
let rev_sign_combine ~(pos: 'a -> 'b) ~(neg : 'a -> 'b) : 'a list -> 'b list list =
  let rec aux acc revpref l =
    match l with
    | [] -> (List.rev revpref) :: acc
    | head :: tail ->
      let acc = aux acc (pos head :: revpref) tail in
      aux acc (neg head :: revpref) tail
  in
  aux [] []

let sign_combine ~pos ~neg l =
  List.rev (rev_sign_combine pos neg l)
